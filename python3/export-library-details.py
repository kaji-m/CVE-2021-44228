######################################################################
# Copyright [2021] Contrast Security, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# DESCRIPTION:
#
# A script to aid in the identification of affected Java applications
# in TeamServer impacted by CVE-2021-44228 (log4j RCE vulnerability)
#
# This script collects a list of apps which have references to libs with
# a specified prefix in their name while going iterating through the users
# and gathering applications they are authorized to access.
#
# The output is a file written out to $CWD/vulnerableApps.csv and contains
# tuples of:
# {(parent) app name, lib name, lib version, use count, and user id list}
#
# PREREQUISITE:
#
# Requires a TeamServer user with view access to all applications and
# a valid API key and AUTH token
#
# USAGE:
#
# The script requires the following environment variables to be set:
#
#     CONTRAST__AUTHORIZATION
#     CONTRAST__API_KEY
#     CONTRAST__ORG
#     CONTRAST__URL             :example -  https://app.contrastsecurity.com/
#
# @author: ching-chiang.van@contrastsecurity.com
#
#####################################################################

# -*- coding: utf-8 -*-
import requests
import json
import io
import os
import re
import sys

CONTRAST_AUTHORIZATION = os.getenv('CONTRAST__AUTHORIZATION', '<<authorization>>')
CONTRAST_API_KEY = os.getenv('CONTRAST__API_KEY', '<<api_key>>')
CONTRAST_ORG = os.getenv('CONTRAST__ORG', '<<orgId>>')
CONTRAST_URL = os.getenv('CONTRAST__URL', "https://app.contrastsecurity.com/")

BASEURL = CONTRAST_URL + "Contrast/api/ng/%s" % CONTRAST_ORG
VERIFY_CERT = False
LIBPREFIX = 'log4j'
headers = {"Accept": "application/json", "Content-Type": "application/json", "API-Key": CONTRAST_API_KEY,
           "Authorization": CONTRAST_AUTHORIZATION}

grpdict = {}
appdict = {}
appusersdict = {}


def getLibsForOrg(pName, pIncr):
    offset = 0

    # urllib = (BASEURL) + "/libraries/filter?expand=skip_links,apps,servers,vulns,manifest,status,usage_counts&limit=%s&offset=%s&sort=score" % (str(pIncr), str(offset))
    urllib = BASEURL + "/libraries/filter?expand=skip_links,apps,vulns,usage_counts&limit=%s&offset=%s&sort=score" % (
    str(pIncr), str(offset))
    jBody = "{\"quickFilter\": \"ALL\", \"q\": \"%s\"}" % pName

    rc = requests.post(urllib, headers=headers, json=json.loads(jBody), verify=VERIFY_CERT)
    if rc.status_code == 400:
        print('*** API call failed. Check authorization credential?')
        sys.exit()
    data = rc.json()

    # paginate through the libraries
    libcnt = data['count']
    liboffset = 0
    while liboffset < libcnt:

        libs = data['libraries']
        for alib in libs:
            libname = alib['file_name']

            # match for library name with the specified prefix string
            if libname[0:5] != pName:
                continue
            libversion = alib['version']

            # check for major and sub version numbers - reporting only 2.x
            # (2.14.1 and below)
            sublist = libversion.split('.')

            if sublist[0] == '1':
                # print('found 1.x')
                continue
            elif (len(sublist) > 1 and int(sublist[1]) > 14) and (len(sublist) > 2 and int(sublist[2]) < 2):
                # print('skipping version > 2.14.1' + libversion)
                continue
            # else:
            #   print(libversion)

            libhash = alib['hash']
            liblang = alib['app_language']
            libclassesusedcount = alib['classes_used']
            apps = alib['apps']
            # servers = []
            # if (alib['servers'] != None):
            #   for asvr in alib['servers']:
            #     servers.append(asvr['server_id'])

            for app in apps:
                appid = app['app_id']
                appname = app['name']

                # Keying on appid which means only the 1st instance with the same
                # prefix will be reported. The same also applies with only the first
                # version number encountered to use compound key with appid, lib name,
                # and version if that needs to be expanded

                if not (appid in appdict):
                    urlapp = (BASEURL) + "/applications/%s?expand=skip_links,license" % appid
                    arc = requests.get(urlapp, headers=headers, verify=VERIFY_CERT)
                    adata = arc.json()
                    pappid = ''
                    pappname = ''

                    if 'parentApplicationId' in adata['application']:
                        pappid = adata['application']['parentApplicationId']
                        urlapp = (BASEURL) + "/applications/%s?expand=skip_links,license" % pappid
                        brc = requests.get(urlapp, headers=headers, verify=VERIFY_CERT)
                        bdata = brc.json()
                        pappname = bdata['application']['name']
                    # adict = {appid: [appname, libname, libhash, libversion, liblang, libclassesused, servers]}
                    adict = {appid: [appname, pappname, libname, libhash, libversion, liblang, libclassesusedcount]}
                    appdict.update(adict)

        liboffset += pIncr
        urllib = (BASEURL) + "/libraries/filter?expand=skip_links,apps&limit=%s&offset=%s" % (pIncr, str(liboffset))
        rc = requests.post(urllib, headers=headers, json=json.loads(jBody), verify=VERIFY_CERT)
        data = rc.json()

    return appdict


# def getGroupsForOrg():
#   urlgrp = (BASEURL) + "/groups?expand=applications,skip_links&sort=name"
#   rc = requests.get(urlgrp, headers=headers, verify=VERIFY_CERT)
#   data = rc.json()
#   adict = {}
#   for agrp in data['custom_groups']['groups']:
#     if ('applications' in agrp):
#       for app in agrp['applications']:
#         appname = app['application']['name']
#         appid = app['application']['app_id']
#         adict = {agrp['group_id']: [agrp['name'], appid, appname]}
#         grpdict.update(adict)
#   return grpdict

def getUsersForOrg():
    urluser = BASEURL + "/users?expand=skip_links&sort=name"
    rc = requests.get(urluser, headers=headers, verify=VERIFY_CERT)
    data = rc.json()

    # get the list of authorized apps accessible by the user
    for auser in data['users']:
        urluseraccess = (BASEURL) + "/users/%s/access?expand=applications,skip_links" % auser['user_uid']
        arc = requests.get(urluseraccess, headers=headers, verify=VERIFY_CERT)
        adata = arc.json()
        for app in adata['applications']:
            # only picking up Java apps
            if ('language' in app) and (not (app['language'] == 'Java')):
                continue
            users = appusersdict.get(app['application']['app_id'])
            if users is not None:
                users.append(auser['user_uid'])
            else:
                users = [auser['user_uid']]
        adict = {app['application']['app_id']: users}
        appusersdict.update(adict)
    return appusersdict.update(adict)


def main():
    # getGroupsForOrg()
    getLibsForOrg(LIBPREFIX, 50)
    getUsersForOrg()

    seperator = ','
    with open('vulnerableApps.csv', 'w') as vf:
        for appid in appdict:
            llist = appdict.get(appid)
            ulist = appusersdict.get(appid)

            # write out {app name, parent app name, library name, version, use count, users}
            appname = llist[0]
            if llist[1] != '':
                appname = llist[1]
            if ulist is not None:
                joinedunames = ','.join(ulist)
                vf.write(appname + seperator + llist[2] + seperator + llist[4] + seperator + str(
                    llist[6]) + seperator + joinedunames + '\n')
            else:
                vf.write(appname + seperator + llist[2] + seperator + llist[4] + seperator + str(llist[6]) + '\n')


if __name__ == '__main__':
    main()
